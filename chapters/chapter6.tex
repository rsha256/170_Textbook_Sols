\section{Chapter 6}

\begin{problem}{6.17}
    \textbf{Given an umlimited supply of coins of denominations $x_1, x_2, ... x_n$, give a dynamic programming algorithm to decide if it is possible to make change for some quantity $V$}. \\
    Subproblem: $f(i, v)$ = if it is possible to make change for $v$ using denominations $x_1, x_2, ... x_i$ \\
    Solution: $f(n, V)$ \\
    Base case: $f(0, 0) = true$; $f(0, v) = false, v \neq 0$ \\
    Recurrence: $f(i, v) = f(i - 1, v)$ or $f(i, v - x_i) $ \\
    Order: increasing order of $i$, $v$ \\
    Time complexity: $O(nV)$ \\
    Space complexity: $O(V)$
\end{problem}

\begin{problem}{6.18}
    \textbf{Solve the coin change problem from above where you are only allowed to use one of each denomination.}. \\
    Subproblem: $f(i, v)$ = if it is possible to make change for $v$ using denominations $x_1, x_2, ... x_i$ \\
    Solution: $f(n, V)$ \\
    Base case: $f(0, 0) = true$; $f(0, v) = false, v \neq 0$ \\
    Recurrence: $f(i, v) = f(i - 1, v)$ or $f(i - 1, v - x_i) $ \\
    Order: increasing order of $i$, $v$ \\
    Time complexity: $O(nV)$ \\
    Space complexity: $O(V)$
\end{problem}

\begin{problem}{6.19}
    \textbf{Solve the coin change problem from above where you have an unlimited supply of each coin but can only use up to $k$ total coins.}. \\
    Subproblem: $f(v)$ = miniminum number of coins to make change for $v$ \\
    Solution: $f(V) \leq k$ \\
    Base case: $f(0) = 0$
    Recurrence: $f(v) = \min_{i}f(v - x_i)$ \\
    Order: increasing order of $v$ \\
    Time complexity: $O(nV)$ \\
    Space complexity: $O(V)$
\end{problem}

\begin{problem}{6.26}
    \textbf{Give a dynamic programming that takes in two strings $x[1...n], y[1...m]$ and returns the max-scoring alignment.} \\
    Subproblem: $f(i, j)$ = max alignment from $x[1...i], y[1...j]$ \\
    Solution: $f(n, m)$ \\
    Base case: $f(0, j) = 0$; $f(i, 0) = 0$ \\
    Recurrence: $f(i, j) = \max(f(i - 1, j) + \delta(x[i],\_\_)), f(i, j - 1) + \delta(\_\_, y[j])), f(i - 1, j - 1) + \delta(x[i], y[j]))$ \\
    Time complexity: $O(mn)$ \\
    Space complexity: $O(\min(m, n))$
\end{problem}

\newpage
\begin{problem}{6.27}
    \textbf{Solve the problem from 6.26 where the penalty for a gap of length k is $c_0 + c_1k$}. \\
    Subproblems: 
        \\ $A(i, j)$ = best score when $x[i]$ and $y[j]$ aligned \\
        $B(i, j)$ = best score when $x[i]$ is aligned with a gap \\
        $C(i, j)$ = best score when $y[j]$ is aligned with a gap \\
    Solution: $\max(A(n, m), B(n, m), C(n, m))$ \\
    Base case: $A(0, 0) = 0; B(i, 0) = c_0 + c_1 * i; C(0, j) = c_0 + c_1 * j$ \\
    Recurrences: \\
    $A(i, j) = \max(A(i - 1, j - 1) + \delta(x[i], y[j]), B(i - 1, j - 1) + \delta(x[i], y[j]), C(i - 1, j - 1) + \delta(x[i], y[j])$ \\
    $B(i,  j) = \max(A(i - 1, j) + c_0 + c_1, B(i - 1, j) + c_1)$ \\
    $C(i,  j) = \max(A(i - 1, j) + c_0 + c_1, C(i - 1, j) + c_1)$ \\
    Time complexity: $O(mn)$ \\
    Space complexity: $O(\min(m, n))$
\end{problem}

\begin{problem}
    \textbf{Solve the problem from 6.26 where your goal is to find a maximum-scoring substring.}
    Subproblem: $f(i, j)$ = score of best alignment of a suffix of $x[1...i]$, $y[1...j]$ \\
    Solution: $max_{i, j} f(i, j)$ \\
    Base case: $f(0, j) = 0$; $f(i, 0) = 0$ \\
    Recurrence: $f(i, j) = \max(f(i - 1, j) + \delta(x[i],\_\_)), f(i, j - 1) + \delta(\_\_, y[j])), f(i - 1, j - 1) + \delta(x[i], y[j]))$ \\
    Time complexity: $O(mn)$ \\
    Space complexity: $O(\min(m, n))$
\end{problem}
